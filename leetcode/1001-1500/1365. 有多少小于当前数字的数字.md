力扣第 178 场周赛的第二道题目，简单难度。

### 描述

给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。

换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] < nums[i] 。

以数组形式返回答案。

示例 1：

```
输入：nums = [8,1,2,2,3]
输出：[4,0,1,1,3]
解释： 
对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 
对于 nums[1]=1 不存在比它小的数字。
对于 nums[2]=2 存在一个比它小的数字：（1）。 
对于 nums[3]=2 存在一个比它小的数字：（1）。 
对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。
```
示例 2：

```
输入：nums = [6,5,4,8]
输出：[2,1,0,3]
```

示例 3：

```
输入：nums = [7,7,7,7]
输出：[0,0,0,0]
```

提示：

- 2 <= nums.length <= 500
- 0 <= nums[i] <= 100

### 解法

自定义数据结构 Data，用来记录数组元素值 val，在数组中的下标 index（因为排序后下标会变化）、小于当前元素的元素个数 count。

将数组从小到大排序，记录每个元素的比它小的元素总数 count。如果当前元素的值 val 比上一个元素的值 val 大，则其 count 是上一个元素的 count + 1，如果当前元素的值 val 等于上一个元素的值 val，则两者的 count 也相等。

时间复杂度：O(n)，空间复杂度：O(n)

```java
class Solution {

    static class Data implements Comparable {
        int val;
        int index;
        int count;

        public Data(int val, int index) {
            this.val = val;
            this.index = index;
        }

        @Override
        public int compareTo(Object o) {
            return this.val - ((Data) o).val;
        }
    }

    public int[] smallerNumbersThanCurrent(int[] nums) {
        if (nums == null || nums.length == 0) {
            return new int[0];
        }
        Data[] data = new Data[nums.length];
        for (int i=0; i < nums.length; i++) {
            data[i] = new Data(nums[i], i);
        }
        Arrays.sort(data);
        int[] res = new int[nums.length];
        int lastLess = 0;
        res[0] = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[i].val > data[i - 1].val) {
                data[i].count += i;
            }
            else if (data[i].val == data[i - 1].val) {
                data[i].count = data[i - 1].count;
            }
            res[data[i].index] = data[i].count;
        }
        return res;
    }
}
```